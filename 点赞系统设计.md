# 缓存设计

分为写缓存和读缓存，分别管理。

|             | 读缓存                   | 写缓存                   |
| ----------- | ----------------------- | ------------------------ |
| 存储点赞用户 | `like:read:{type}:{id}` | `like:write:{type}:{id}` |
| 存储点赞数   | `like-count:{type}:{id}` | 同左 |

读缓存的内容是与数据库保持高度同步的，并非最新内容；用户的最新操作保存在写缓存中，写缓存并不包含全部内容。因此在写入数据时，只需将数据写入写缓存；读取数据时，则需将读写缓存内容合并。写缓存定期写入数据库，同时写入读缓存。点赞数不区分读写缓存，采用写回法。

读写缓存分开有利于分别控制同步与过期。当然也可以直接使用「写回法」设置缓存，不区分读写缓存，不过可能在用户写入时需要设置分布式锁以防止多用户同时操作时，重复读库和写入缓存导致的数据不一致。

当然，当前的方案仍有不一致问题：在写缓存定期写库的时候，如果有读取请求，可能会导致不一致。不过这个发生几率小于写回法的写入不一致，而且不会对最终数据产生影响。如果要解决不一致问题，可以在定期同步时设置锁，在用户读取时检查锁即可。

在存储点赞用户时，使用set保存用户id，如果是点赞则保存用户id本身，如果是取消点赞，则保存负的用户id。在读取数据时，始终以写缓存的数据为最新，如果写缓存有正，表示点赞，如果写缓存有负，无论读缓存及库里有无正值，都表示取消点赞。而在定期同步时，将对应数据合并，因此读缓存和库中只保存正值，取消则删除相关记录；而写缓存中则有正有负（但同一id只能是正或负，不能同时出现）。
